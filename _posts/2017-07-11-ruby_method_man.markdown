---
layout: post
title:      "Ruby: Method (Man)"
date:       2017-07-10 23:41:49 -0400
permalink:  ruby_method_man
---


![Method Man Cheese The Wire](https://media.giphy.com/media/4k09dOUkexUs0/giphy.gif)

I had a revelation this past week. Call it a message. Better yet, call it a method.

![Angela Merkel Eye Roll](http://i.imgur.com/m4XytnK.png)

Because that's what dominates Ruby--methods. 

Have some information you need stored? There's a method for that. Need to fetch some data? There's a method for that! Need to make a method? Yes, there's a method for that too. 

In fact, even code that doesn't appear to explicitly be a method, is, in fact, a method. 

```
method_man = ["himself", "The Cheese", "Diego"]
```
Think that's just an array coming into being? Nope. That's actually the "equals" method in action.

```
attr_accessor :album, :collaborator, :tour
```
Now that's not just a method; it's a mega-method--a macro: code that writes methods for you. And, of course, there are methods that write methods: #define_method. So meta.

![Computers inside computers](https://media.giphy.com/media/yAOjunY81Trjy/giphy.gif)

This all makes sense too. Ruby is designed to be intuitive. Object orientation is designed to mimic the real world. And the real world is composed of actions. Think about it. Even when you're simply storing your Method Man albums--you're still *storing* them. You're acting on them. Doing something with them. I mean, try to think of a time when you aren't *doing* something. Just try. 
 
I'm willing to wager that you can't. Because by virtue of existing, we're doing something. We *are*. So it's perfectly logical that Ruby would be dominated by methods, by actions. We can't not not be. We simply are. Or, in the words of a man of the Wu-Tang Clan,  "I am, the one and only Method Man".

![Method Man](http://i.imgur.com/nZc0yNG.jpg)




